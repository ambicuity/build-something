# Build Your Own Programming Language

Create programming languages from scratch and understand the fundamentals of language design, compilation, and interpretation. Master lexical analysis, parsing, and code generation.

## üéØ What You'll Learn

- Language design principles and syntax considerations
- Lexical analysis and tokenization
- Parsing techniques and grammar design
- Abstract syntax trees and semantic analysis
- Code generation and virtual machine design
- Type systems and memory management

## üìö Tutorials by Language

### Universal/Multiple Languages
- **[mal - Make a Lisp](https://github.com/kanaka/mal)** - Lisp implementation in 70+ languages
- **[Build Your Own Lisp: Learn C and build your own programming language in 1000 lines of code](http://www.buildyourownlisp.com/)** - C-based Lisp tutorial

### Assembly
- **[Jonesforth](https://github.com/nornagon/jonesforth/blob/master/jonesforth.S)** - Forth implementation in assembly

### C
- **[Baby's First Garbage Collector](http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/)** - Memory management implementation
- **[Writing a Simple Garbage Collector in C](https://maplant.com/gc.html)** - Garbage collection techniques
- **[C interpreter that interprets itself](https://github.com/lotabout/write-a-C-interpreter)** - Self-hosting interpreter
- **[A C & x86 version of the "Let's Build a Compiler" by Jack Crenshaw](https://github.com/lotabout/Let-s-build-a-compiler)** - Classic compiler tutorial
- **[A journey explaining how to build a compiler from scratch](https://github.com/DoctorWkt/acwj)** - Comprehensive compiler series

### C++
- **[Writing Your Own Toy Compiler Using Flex](https://gnuu.org/2009/09/18/writing-your-own-toy-compiler/)** - Lexer/parser tools
- **[How to Create a Compiler [video]](https://www.youtube.com/watch?v=eF9qWbuQLuw)** - Video tutorial series
- **[Kaleidoscope: Implementing a Language with LLVM](https://llvm.org/docs/tutorial/)** - LLVM-based language tutorial

### F#
- **[Understanding Parser Combinators](https://fsharpforfunandprofit.com/posts/understanding-parser-combinators/)** - Functional parsing techniques

### Elixir
- **[Demystifying compilers by writing your own [video]](https://www.youtube.com/watch?v=zMJYoYwOCd4)** - Elixir compiler tutorial

### Go
- **[The Super Tiny Compiler](https://github.com/hazbo/the-super-tiny-compiler)** - Minimal compiler in Go
- **[Lexical Scanning in Go [video]](https://www.youtube.com/watch?v=HxaD_trXwRE)** - Rob Pike's lexer talk

### Haskell
- **[Let's Build a Compiler](https://g-ford.github.io/cradle/)** - Haskell compiler tutorial
- **[Write You a Haskell](http://dev.stephendiehl.com/fun/)** - Complete language implementation
- **[Write Yourself a Scheme in 48 Hours](https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours)** - Classic Scheme tutorial
- **[Write You A Scheme](https://www.wespiser.com/writings/wyas/home.html)** - Modern Scheme implementation

### Java
- **[Crafting interpreters: A handbook for making programming languages](http://www.craftinginterpreters.com/)** - Comprehensive language implementation
- **[Creating JVM Language](https://github.com/asatarin/jvm-languages-snippets)** - JVM-targeted languages

### JavaScript
- **[The Super Tiny Compiler](https://github.com/jamiebuilds/the-super-tiny-compiler)** - Minimal compiler tutorial
- **[The Super Tiny Interpreter](https://github.com/keyanzhang/the-super-tiny-interpreter)** - Simple interpreter
- **[Little Lisp interpreter](https://maryrosecook.com/blog/post/little-lisp-interpreter)** - Lisp in JavaScript
- **[How to implement a programming language in JavaScript](https://lisperator.net/pltut/)** - Complete language tutorial
- **[Let's go write a Lisp](https://idiocy.org/lets-go-write-a-lisp/part-1.html)** - Interactive Lisp tutorial

### OCaml
- **[Writing a C Compiler](https://norasandler.com/2017/11/29/Write-a-Compiler.html)** - C compiler in OCaml
- **[Writing a Lisp, the series](https://bernsteinbear.com/blog/lisp/)** - Lisp implementation series

### Pascal
- **[Let's Build a Compiler](https://compilers.iecc.com/crenshaw/)** - Classic compiler tutorial

### Python
- **[A Python Interpreter Written in Python](http://www.aosabook.org/en/500L/a-python-interpreter-written-in-python.html)** - Python implementation
- **[lisp.py: Make your own Lisp interpreter](http://khamidou.com/compilers/lisp.py/)** - Python Lisp interpreter
- **[How to Write a Lisp Interpreter in Python](http://norvig.com/lispy.html)** - Peter Norvig's tutorial
- **[Let's Build A Simple Interpreter](https://ruslanspivak.com/lsbasi-part1/)** - Comprehensive interpreter series
- **[Make Your Own Simple Interpreted Programming Language [video]](https://www.youtube.com/watch?v=dj9CBS3ikGA&list=PLZQftyCk7_SdoVexSmwy_tBgs7P0b97yD)** - Video tutorial series
- **[From Source Code To Machine Code: Build Your Own Compiler From Scratch](https://build-your-own.org/compiler/)** - Complete compiler tutorial

### Racket
- **[Beautiful Racket: How to make your own programming languages with Racket](https://beautifulracket.com/)** - Language-oriented programming

### Ruby
- **[A Compiler From Scratch](https://www.destroyallsoftware.com/screencasts/catalog/a-compiler-from-scratch)** - Ruby compiler tutorial
- **[Markdown compiler from scratch in Ruby](https://blog.beezwax.net/2017/07/07/writing-a-markdown-compiler/)** - Domain-specific language

### Rust
- **[Learning Parser Combinators With Rust](https://bodil.lol/parser-combinators/)** - Parsing in Rust

### Swift
- **[Building a LISP from scratch with Swift](https://www.uraimo.com/2017/02/05/building-a-lisp-from-scratch-with-swift/)** - Swift Lisp implementation

### TypeScript
- **[Build your own WebAssembly Compiler](https://blog.scottlogic.com/2019/05/17/webassembly-compiler.html)** - WebAssembly target compilation

## üèóÔ∏è Project Ideas

### Beginner Projects
1. **Calculator Language** - Mathematical expression evaluator
2. **Configuration Language** - Simple data description language
3. **Template Language** - Text substitution and formatting

### Intermediate Projects
1. **Scripting Language** - Dynamic programming language
2. **Domain-Specific Language** - Problem-specific language design
3. **Functional Language** - Lambda calculus-based language

### Advanced Projects
1. **Systems Language** - Low-level programming language
2. **Object-Oriented Language** - Class-based programming language
3. **Concurrent Language** - Language with built-in concurrency

## üß™ Language Components

### Frontend (Analysis)
- **Lexical Analysis**: Breaking source code into tokens
- **Syntax Analysis**: Parsing tokens into abstract syntax tree
- **Semantic Analysis**: Type checking and symbol resolution
- **Error Recovery**: Handling and reporting syntax errors

### Backend (Synthesis)
- **Code Generation**: Translating AST to target code
- **Optimization**: Improving generated code efficiency
- **Register Allocation**: Efficient CPU register usage
- **Linking**: Combining separately compiled modules

### Runtime System
- **Memory Management**: Allocation and garbage collection
- **Type System**: Static or dynamic type checking
- **Exception Handling**: Error propagation and handling
- **Standard Library**: Built-in functions and data types

## üé® Language Design Choices

### Syntax Design
- **Grammar Type**: Context-free, context-sensitive, or unrestricted
- **Operator Precedence**: Mathematical and logical operator priority
- **Statement vs Expression**: Language composition principles
- **Whitespace Significance**: Python-style vs C-style syntax

### Type Systems
- **Static Typing**: Compile-time type checking (Java, C++)
- **Dynamic Typing**: Runtime type checking (Python, JavaScript)
- **Strong vs Weak**: Type coercion behavior
- **Inference**: Automatic type deduction (Haskell, ML)

### Memory Models
- **Manual Management**: Explicit allocation/deallocation (C, C++)
- **Garbage Collection**: Automatic memory management (Java, Python)
- **Reference Counting**: Automatic cleanup with cycles (Swift, Python)
- **Ownership System**: Compile-time memory safety (Rust)

### Paradigm Support
- **Imperative**: Step-by-step instruction execution
- **Functional**: Function composition and immutability
- **Object-Oriented**: Encapsulation and inheritance
- **Concurrent**: Parallel and asynchronous execution

## üîß Implementation Techniques

### Parsing Methods
- **Recursive Descent**: Top-down parsing with recursive functions
- **LR Parsing**: Bottom-up shift-reduce parsing
- **Parser Combinators**: Compositional parsing libraries
- **PEG Parsers**: Parsing Expression Grammar approach

### Code Generation
- **Interpreter**: Direct AST evaluation
- **Bytecode VM**: Virtual machine with custom instruction set
- **Native Code**: Direct machine code generation
- **Transpilation**: Translation to another high-level language

### Optimization Strategies
- **Constant Folding**: Compile-time expression evaluation
- **Dead Code Elimination**: Removing unreachable code
- **Common Subexpression**: Avoiding redundant computations
- **Tail Call Optimization**: Converting recursion to iteration

## üìö Theoretical Foundations

### Formal Language Theory
- **Regular Languages**: Finite automata and regular expressions
- **Context-Free Languages**: Pushdown automata and grammars
- **Turing Completeness**: Computational equivalence principles
- **Decidability**: Limits of static analysis

### Type Theory
- **Lambda Calculus**: Foundation of functional programming
- **Type Inference**: Hindley-Milner type system
- **Dependent Types**: Types that depend on values
- **Linear Types**: Resource usage tracking

### Compiler Theory
- **Data Flow Analysis**: Variable usage and modification tracking
- **Control Flow Analysis**: Program execution path analysis
- **SSA Form**: Single static assignment intermediate representation
- **Register Allocation**: Graph coloring and linear scan algorithms

## üîó Additional Resources

- [Programming Language Pragmatics](https://www.cs.rochester.edu/~scott/pragmatics/) - Comprehensive language design textbook
- [Types and Programming Languages](https://www.cis.upenn.edu/~bcpierce/tapl/) - Type system theory and implementation
- [Compilers: Principles, Techniques, and Tools](https://suif.stanford.edu/dragonbook/) - Classic "Dragon Book"
- [Language Implementation Patterns](https://pragprog.com/titles/tpdsl/language-implementation-patterns/) - Practical language building techniques

---

**Ready to create?** Start with a simple expression evaluator and evolve into a full programming language!